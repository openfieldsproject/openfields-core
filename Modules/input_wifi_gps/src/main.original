/*
 * Module Name: input_wifigps
 * Description: TCP Socket to receive encrypted gps nmea sentence payloads
 * Author: Gavin Behrens
 * License: GPLv3
 * Dependencies: mqtt_client.h sys/socket, openssl
 * Notes:
 *   - Publishes to: /RAW/NMEA/gps
 *   - AES128-CBC necessary -
 *
 * Style: NASA Power of Ten (safety-oriented C). Static allocation, bounded loops, single return.
 * Frame format per message:
 * [16-byte IV]
 * [4-byte big-endian uint32: ciphertext_len]
 * [ciphertext_len bytes: AES-128-CBC of plaintext (PKCS#7 padding)]
 */

#include <openssl/evp.h>
#include <openssl/err.h>
#include <mosquitto.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <openssl/aes.h>
#include <openssl/evp.h>
#include <mosquitto.h>

#define LISTEN_PORT   10001
#define MQTT_HOST     "172.18.200.101"
#define MQTT_PORT     1883
#define MQTT_TOPIC    "RAW/NMEA/gps"

static const unsigned char g_aes_key[16] =
{
  0x00,0x11,0x22,0x33,
  0x44,0x55,0x66,0x77,
  0x88,0x99,0xaa,0xbb,
  0xcc,0xdd,0xee,0xff
};

static struct mosquitto *g_mosq = NULL;

static int mqtt_init(void)
{
  int status = 0;

  mosquitto_lib_init();

  g_mosq = mosquitto_new("nmea-gps-server", true, NULL);
  if(!g_mosq)
    status = 0;
  else if(mosquitto_connect(g_mosq, MQTT_HOST, MQTT_PORT, 60) != MOSQ_ERR_SUCCESS)
    status = 0;
  else
    status = 1;

  return status;
}

static void mqtt_cleanup(void)
{
  if(g_mosq)
  {
    mosquitto_disconnect(g_mosq);
    mosquitto_destroy(g_mosq);
  }

  mosquitto_lib_cleanup();
}

static void mqtt_publish(const char *line)
{
  if(g_mosq)
  {
    mosquitto_publish(g_mosq, NULL, MQTT_TOPIC, (int) strlen(line), line, 1, false);
  }
}

static int decrypt_message(unsigned char *cipher, int cipher_len,
                           unsigned char *iv, char *out, int out_size)
{
  EVP_CIPHER_CTX *ctx;
  int len = 0, plain_len = 0;

  ctx = EVP_CIPHER_CTX_new();
  if (!ctx)
    return -1;

  if (EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, g_aes_key, iv) != 1)
  {
    EVP_CIPHER_CTX_free(ctx);
    return -1;
  }

  if (EVP_DecryptUpdate(ctx, (unsigned char *)out, &len, cipher, cipher_len) != 1)
  {
    EVP_CIPHER_CTX_free(ctx);
    return -1;
  }
  plain_len = len;

  if (EVP_DecryptFinal_ex(ctx, (unsigned char *)out + len, &len) != 1)
  {
    EVP_CIPHER_CTX_free(ctx);
    return -1;
  }
  plain_len += len;

  EVP_CIPHER_CTX_free(ctx);

  if (plain_len >= out_size)
    return -1;

  out[plain_len] = '\0';
  return plain_len;
}

static void handle_client(int client_fd)
{
  unsigned char iv[16];
  unsigned char buffer[1024];
  char plaintext[1024];
  __uint32_t cipher_len = 0;
  int plain_len = 0;
  ssize_t n = 0;

  n = read(client_fd, iv, 16);
  if(n != 16)
    return;

  uint32_t net_len;

  n = read(client_fd, &net_len, 4);
  if(n != 4)
    return;

  cipher_len = ntohl(net_len);
  if(cipher_len <= 0 || cipher_len > (int)sizeof(buffer))
    return;

  n = read(client_fd, buffer, cipher_len);
  if(n != cipher_len)
    return;

  plain_len = decrypt_message(buffer, (int) cipher_len, iv, plaintext, sizeof(plaintext));
  if(plain_len > 0)
    mqtt_publish(plaintext);
}

int main(void)
{
  int server_fd;
  int client_fd;
  struct sockaddr_in addr;
  socklen_t addrlen = sizeof(addr);

  if(!mqtt_init())
  {
    fprintf(stderr, "MQTT init failed\n");
    return 1;
  }

  server_fd = socket(AF_INET, SOCK_STREAM, 0);
  if(server_fd < 0)
  {
    perror("socket");
    return 1;
  }

  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = INADDR_ANY;
  addr.sin_port = htons(LISTEN_PORT);

  if(bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0)
  {
    perror("bind");
    close(server_fd);
    return 1;
  }

  if(listen(server_fd, 5) < 0)
  {
    perror("listen");
    close(server_fd);
    return 1;
  }

  printf("Server listening on port %d\n", LISTEN_PORT);

  for(;;)
  {
    client_fd = accept(server_fd, (struct sockaddr*)&addr, &addrlen);
    if(client_fd < 0)
    {
      perror("accept");
      continue;
    }

    handle_client(client_fd);
    close(client_fd);
  }

  mqtt_cleanup();
  close(server_fd);

  return 0;
}
