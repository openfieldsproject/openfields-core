/*
 * Module Name: input_wifigps
 * Description: TCP Socket to receive encrypted gps nmea sentence payloads
 * Author: Gavin Behrens
 * License: GPLv3
 * Dependencies: mqtt_client.h sys/socket, openssl
 * Notes:
 *   - Publishes to: /RAW/NMEA/gps
 *   - AES128-CBC necessary -
 *
 * Style: NASA Power of Ten (safety-oriented C). Static allocation, bounded loops, single return.
 * Frame format per message:
 * [16-byte IV]
 * [4-byte big-endian uint32: ciphertext_len]
 * [ciphertext_len bytes: AES-128-CBC of plaintext (PKCS#7 padding)]
 */

#include <arpa/inet.h>
#include <errno.h>
#include <netinet/in.h>
#include <openssl/evp.h>
#include <openssl/aes.h>
#include <mosquitto.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <unistd.h>

#define LISTEN_PORT   10001
#define MQTT_HOST     "172.18.200.101"
#define MQTT_PORT     1883
#define MQTT_TOPIC    "RAW/NMEA/gps"

static const unsigned char g_aes_key[16] =
{0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,
 0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff};

static struct mosquitto *g_mosq = NULL;

// ---------------- MQTT helpers ----------------
static int mqtt_init(void) {
    mosquitto_lib_init();
    g_mosq = mosquitto_new("nmea-gps-server", true, NULL);
    if(!g_mosq) return 0;
    if(mosquitto_connect(g_mosq, MQTT_HOST, MQTT_PORT, 60) != MOSQ_ERR_SUCCESS) return 0;
    return 1;
}

static void mqtt_cleanup(void) {
    if(g_mosq) {
        mosquitto_disconnect(g_mosq);
        mosquitto_destroy(g_mosq);
    }
    mosquitto_lib_cleanup();
}

static void mqtt_publish(const char *line) {
    if(g_mosq)
        mosquitto_publish(g_mosq, NULL, MQTT_TOPIC, (int)strlen(line), line, 1, false);
}

// ---------------- AES decrypt ----------------
static int decrypt_message(unsigned char *cipher, int cipher_len,
                           unsigned char *iv, char *out, int out_size)
{
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if(!ctx) return -1;

    if(EVP_DecryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, g_aes_key, iv) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }

    int len = 0, plain_len = 0;
    if(EVP_DecryptUpdate(ctx, (unsigned char *)out, &len, cipher, cipher_len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }
    plain_len = len;

    if(EVP_DecryptFinal_ex(ctx, (unsigned char *)out + len, &len) != 1) {
        EVP_CIPHER_CTX_free(ctx);
        return -1;
    }
    plain_len += len;
    EVP_CIPHER_CTX_free(ctx);

    if(plain_len >= out_size) return -1;
    out[plain_len] = '\0';
    return plain_len;
}

// ---------------- TCP helpers ----------------
ssize_t read_n_bytes(int fd, void *buf, size_t n) {
    size_t total = 0;
    char *ptr = buf;
    while(total < n) {
        ssize_t r = read(fd, ptr + total, n - total);
        if(r <= 0) return r; // error or closed
        total += (size_t) r;
    }
    return (int)total;
}

void handle_client(int client_fd) {
    unsigned char iv[16];
    unsigned char buffer[1024];
    char plaintext[1024];

    while(1) {
        ssize_t n = read_n_bytes(client_fd, iv, 16);
        if(n <= 0) break;

        uint32_t net_len;
        n = read_n_bytes(client_fd, &net_len, 4);
        if(n <= 0) break;

        uint32_t cipher_len = ntohl(net_len);
        if(cipher_len <= 0 || cipher_len > sizeof(buffer)) break;

        n = read_n_bytes(client_fd, buffer, cipher_len);
        if(n <= 0) break;

        int plain_len = decrypt_message(buffer, (int)cipher_len, iv, plaintext, sizeof(plaintext));
        if(plain_len > 0) {
            mqtt_publish(plaintext);
            printf("Received: %s\n", plaintext);
        }
    }
    close(client_fd);
    printf("Client disconnected\n");
}

int main(void) {
    if(!mqtt_init()) {
        fprintf(stderr, "MQTT init failed\n");
        return 1;
    }

    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if(server_fd < 0) { perror("socket"); return 1; }

    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(LISTEN_PORT);

    if(bind(server_fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind"); close(server_fd); return 1;
    }

    if(listen(server_fd, 5) < 0) { perror("listen"); close(server_fd); return 1; }
    printf("Server listening on port %d\n", LISTEN_PORT);

    fd_set readfds;
    int max_fd = server_fd;

    while(1) {
        FD_ZERO(&readfds);
        FD_SET(server_fd, &readfds);

        int activity = select(max_fd + 1, &readfds, NULL, NULL, NULL);
        if(activity < 0 && errno != EINTR) { perror("select"); break; }

        if(FD_ISSET(server_fd, &readfds)) {
            struct sockaddr_in client_addr;
            socklen_t addrlen = sizeof(client_addr);
            int client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &addrlen);
            if(client_fd >= 0) {
                printf("Accepted connection from %s:%d\n",
                       inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));
                handle_client(client_fd);
            }
        }
    }

    mqtt_cleanup();
    close(server_fd);
    return 0;
}
